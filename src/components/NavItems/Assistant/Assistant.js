import React, {useEffect, useRef, useState} from "react";
import {useDispatch, useSelector} from "react-redux";
import {useParams} from "react-router-dom";

import axios from "axios";
import {Box, Button,Paper, TextField} from "@material-ui/core";
import Card from "@material-ui/core/Card";
import CardContent from "@material-ui/core/CardContent";
import DuoIcon from '@material-ui/icons/Duo';
import Divider from "@material-ui/core/Divider";
import Grid from "@material-ui/core/Grid";
import ImageIcon from '@material-ui/icons/Image';
import FaceIcon from "@material-ui/icons/Face";
import Typography from "@material-ui/core/Typography";

import AssistantResult from "./AssistantResult";
import CloseResult from "../../Shared/CloseResult/CloseResult";
import CustomTile from "../../Shared/CustomTitle/CustomTitle";
import ImageGridList from "../../Shared/ImageGridList/ImageGridList";
import VideoGridList from "../../Shared/VideoGridList/VideoGridList";
import {setError} from "../../../redux/actions/errorActions";
import tsv from "../../../LocalDictionary/components/NavItems/tools/Assistant.tsv";
import useMyStyles from "../../Shared/MaterialUiStyles/useMyStyles";
import useLoadLanguage from "../../../Hooks/useLoadLanguage";

import {
    cleanAssistantState, setHelpMessage, setImageVideoSelected,
    setInputUrl, setMediaLists, setProcessUrl, setProcessUrlActions,
    setUrlMode,
} from "../../../redux/actions/tools/assistantActions";
import {
    CONTENT_TYPE, TYPE_PATTERNS,
    matchPattern, selectCorrectActions, KNOWN_LINK_PATTERNS, KNOWN_LINKS,
} from "./AssistantRuleBook";
import history from "../../Shared/History/History";

// todo: twitter iframe fix, instagram logged in fix
const Assistant = () => {

    // styles, language, dispatch, scrapers
    const classes = useMyStyles();
    const dispatch = useDispatch();
    const keyword = useLoadLanguage("components/NavItems/tools/Assistant.tsv", tsv);

    //assistant state values
    const {url} = useParams();
    const urlMode = useSelector(state => state.assistant.urlMode);
    const imageVideoSelected = useSelector(state => state.assistant.imageVideoSelected);
    const inputUrl = useSelector(state => state.assistant.inputUrl);
    const processUrl = useSelector(state => state.assistant.processUrl);
    const processUrlActions = useSelector(state => state.assistant.processUrlActions);
    const imageList = useSelector(state => state.assistant.imageList);
    const videoList = useSelector(state => state.assistant.videoList);
    const helpMessage = useSelector(state => state.assistant.helpMessage);

    //other state values
    const [formInput, setFormInput] = useState(null);

    //refs
    const imageListRef = useRef(imageList);
    const videoListRef = useRef(videoList);

    //Check the input url for data. Figure out which url type and set required image/video lists
    const submitInputUrl = async (userInput) => {
        try {
            // get url type and set media lists according to url
            let urlType = matchPattern(userInput, KNOWN_LINK_PATTERNS);
            const updatedUserInput = await setMediaListsByUrl(urlType, userInput);

            // set assistant state to reflect media lists
            dispatch(setMediaLists(imageListRef.current, videoListRef.current))
            dispatch(setInputUrl(updatedUserInput));

            // if only one image/video exists, set this to be processed with an intermediate step
            handleOneMediaListResult();
        }
        catch (error) {
            dispatch(setError(error.message));
        }
    }

    /* Check if the browser has any stored media lists.
    ** These are generated by popup.js when opening the assistant from another page and contain all possible
    ** scraped images and videos from said page */
    const checkForMediaLists = () => {
        let urlImageList = window.localStorage.getItem("imageList");
        let urlVideoList = window.localStorage.getItem("videoList");

<<<<<<< HEAD
        if (urlImageList === null && urlVideoList === null) {return;}
=======
        if (urlImageList == null && urlVideoList == null) {return;}
>>>>>>> de1a896... Remove assistant warning an errors
        else if (urlImageList !== "" || urlVideoList !== "") {
            // filter out any duplicated images and images we can't process
            imageListRef.current = urlImageList !== "" ? urlImageList.split(",") : [];
            imageListRef.current = imageListRef.current.filter(imageUrl => matchPattern(imageUrl, TYPE_PATTERNS));

            videoListRef.current = urlVideoList !== "" ? urlVideoList.split(",") : [];
        }
    }

    // if there is only one image/video, set this to be processed
    const handleOneMediaListResult = () => {
<<<<<<< HEAD
        if (imageListRef.current.length === 1 && videoListRef.current.length === 0) {
            dispatch(setProcessUrl(imageListRef.current[0]))}
        else if(videoListRef.current.length === 1 && imageListRef.current.length === 0){
=======
        if (imageListRef.current.length === 1 && videoListRef.current.length===0) {
            dispatch(setProcessUrl(imageListRef.current[0]))}
        else if(videoListRef.current.length === 1 && imageListRef.current.length===0){
>>>>>>> de1a896... Remove assistant warning an errors
            dispatch(setProcessUrl(videoListRef.current[0]))}
    }

    // handle specific urls in specific ways to populate image/video lists
    const setMediaListsByUrl = async (urlType, userInput) => {
        switch(urlType) {
            case KNOWN_LINKS.YOUTUBE:
            case KNOWN_LINKS.LIVELEAK:
            case KNOWN_LINKS.VIMEO:
            case KNOWN_LINKS.DAILYMOTION:
                videoListRef.current = [userInput];
                break;
            case KNOWN_LINKS.TIKTOK:
                checkForMediaLists(userInput);
                imageListRef.current = [];
                break;
            case KNOWN_LINKS.INSTAGRAM:
                handleInstagramLink(userInput);
                dispatch(setHelpMessage("assistant_handled_site"));
                break;
            case KNOWN_LINKS.FACEBOOK:
                let updatedUserInputs = userInput.match(KNOWN_LINK_PATTERNS
                    .find(pattern=>pattern.key === KNOWN_LINKS.FACEBOOK).patterns);
                if (updatedUserInputs) userInput = updatedUserInputs[0];

                handleFacebookLink(userInput);
                dispatch(setHelpMessage("assistant_handled_site"));
                break;
            case KNOWN_LINKS.TWITTER:
                try {
                    await handleTwitterLink(userInput);
                    dispatch(setHelpMessage("assistant_handled_site"));
                }
                catch(error){
                    throw new Error(keyword("error_unknown"));}
                break;
            case KNOWN_LINKS.MISC:
                let contentType = matchPattern(userInput, TYPE_PATTERNS);
                if(contentType!==null) {
                    if (contentType === CONTENT_TYPE.IMAGE) imageListRef.current = [userInput];
                    else if (contentType === CONTENT_TYPE.VIDEO) videoListRef.current = [userInput];
                }
                else{checkForMediaLists();}
                break;
            default:
                throw new Error(keyword("please_give_a_correct_link"));
        }
        return userInput;
    }

    /* if video link, use direct link
    ** if image link, filter for those which are post uploads rather than profile pictures etc.*/
    const handleFacebookLink = (userInput) => {
        if(userInput.includes("/photos/")){
            checkForMediaLists(userInput);
            videoListRef.current = [];
            imageListRef.current =
                imageListRef.current.filter(imageUrl => imageUrl.includes("//scontent") &&
                    !(imageUrl.includes("/cp0/")));
        }
        else if(userInput.includes("/videos/")){
            videoListRef.current = [userInput];
            imageListRef.current = [];
        }

    }

    /* if video link, use it, and get rid of any image references
    ** if image links, filter for the first in the list. this is always (hopefuly...) the one in the post.*/
    const handleInstagramLink = (userInput) => {
        checkForMediaLists(userInput);
        if(videoListRef.current.length === 1){imageListRef.current = []}
        else {imageListRef.current = imageListRef.current.length>0 ?  [imageListRef.current[1]] : []}
    }

    /* use analysis backend to figure out if this is an image/video post
    ** if video post, use post url and get rid of all image urls
    ** if image post, filter for post images, rather than profile pictures etc .*/
    const handleTwitterLink = async (userInput) => {
        let createJob = await axios.post("http://mever.iti.gr/caa/api/v4/videos/jobs?url=" + userInput.replace("&", "%26"));
        let createdJobId = (createJob["data"]).id;
        let requestStatus = await axios.get("http://mever.iti.gr/caa/api/v4/videos/jobs/" + createdJobId);

        if(requestStatus.data.status === "unavailable"){
            checkForMediaLists(userInput);

            imageListRef.current = imageListRef.current.filter(imageUrl => imageUrl.includes("/media"));
            videoListRef.current = [];}
        else{
            videoListRef.current = [userInput];
            imageListRef.current = [];
        }
        dispatch(setHelpMessage("assistant_handled_site"));
    }

    // if the user wants to upload a file, give them tools where this is an option
    const submitUpload = (contentType) => {
        let known_link = KNOWN_LINKS.OWN;
        let actions = selectCorrectActions(contentType, known_link, known_link, "");
        dispatch(setProcessUrlActions(contentType, actions));
        dispatch(setImageVideoSelected(true));
    }

    // select the correct media to process, then load actions possible
    const submitMediaToProcess = (url) => {
        dispatch(setProcessUrl(url));
    }


    // clean assistant state
    const cleanAssistant = () => {

        //clean stored browser vars and refs
        window.localStorage.removeItem("imageList");
        window.localStorage.removeItem("videoList");
        imageListRef.current = [];
        videoListRef.current = [];

        //clean state and input
        dispatch(cleanAssistantState());
        setFormInput("");
    }

    // is a url is present in the plugin url(as a param), set it to input and process results
    useEffect(() => {
        if (url !== undefined) {
            let uri = ( url!== null) ? decodeURIComponent(url) : undefined;
            dispatch(setUrlMode(true));
            submitInputUrl(uri);
            history.push("/app/assistant/");
        }
         // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [url, dispatch])

    // if the user types anything into the input box, set it as the new form input
    useEffect(() => {
        setFormInput(inputUrl)
    },[inputUrl])

    // if the processUrl changes, load any actions that can be taken on this new url
    useEffect(() => {
<<<<<<< HEAD
        if (processUrl!==null){loadProcessUrlActions();}
    }, [processUrl]);
=======
        // load possible actions for selected media url
        const loadProcessUrlActions = () => {
            let contentType = null;

            if(imageListRef.current.includes(processUrl)) {contentType = CONTENT_TYPE.IMAGE}
            else if (videoListRef.current.includes(processUrl)) {contentType = CONTENT_TYPE.VIDEO};

            let knownInputLink = matchPattern(inputUrl, KNOWN_LINK_PATTERNS);
            let knownProcessLink = matchPattern(processUrl, KNOWN_LINK_PATTERNS);
            let actions = selectCorrectActions(contentType, knownInputLink, knownProcessLink, processUrl);

            dispatch(setProcessUrlActions(contentType, actions))
        }
        if (processUrl!=null){loadProcessUrlActions();}
    }, [processUrl, dispatch, inputUrl ]);
>>>>>>> de1a896... Remove assistant warning an errors


    return (
        <Paper className = {classes.root}>
            <CustomTile text={keyword("assistant_title")}/>
            <Box m={3}/>

            <Grid container spacing={2}>
                <Grid item xs = {12} className={classes.newAssistantGrid}  hidden={urlMode!==null}>
                    <Typography component={"span"} variant={"h6"} >
                        <FaceIcon fontSize={"small"}/> {keyword("assistant_real_intro")}
                    </Typography>
                    <Box m={2}/>
                    <Button className={classes.button} variant = "contained" color="primary" onClick={() =>dispatch(setUrlMode(true))}>
                        {keyword("process_url") || ""}
                    </Button>
                    <Button className={classes.button} variant="contained" color="primary"  onClick={() => dispatch(setUrlMode(false))}>
                        {keyword("submit_own_file") || ""}
                    </Button>
                </Grid>


                <Grid item xs = {12} className={classes.newAssistantGrid}  hidden={urlMode===null || urlMode===false}>
                    <Box m={5}/>
                    <CloseResult hidden={urlMode===null || urlMode===false} onClick={() => cleanAssistant()}/>

                    <Typography component={"span"} variant={"h6"} >
                        <FaceIcon fontSize={"small"}/> {keyword("assistant_intro")}
                    </Typography>

                    <Box m={2}/>
                    <TextField
                        id="standard-full-width"
                        variant="outlined"
                        label={keyword("assistant_urlbox")}
                        style={{margin: 8}}
                        placeholder={""}
                        fullWidth
                        value={formInput || ""}
                        onChange={e => setFormInput(e.target.value)}
                    />

                    <Box m={2}/>
                    <Button variant="contained" color="primary"
                            align={"center"} onClick={() => {submitInputUrl(formInput)}}>
                        {keyword("button_submit") || ""}
                    </Button>
                </Grid>

                <Grid container spacing={2}>
                    <Grid item xs = {12}
                          className={classes.newAssistantGrid}
                          hidden={imageList.length<=1 && videoList.length<=1}>
                        <Box m={5}/>
                        <Typography component={"span"} variant={"h6"} >
                            <FaceIcon fontSize={"small"}/> {keyword("media_below")}
                        </Typography>
                    </Grid>

                    <Grid item xs = {6}
                          className={classes.newAssistantGrid}
                          hidden={(imageList.length===0 )||(imageList.length<=1 && videoList.length<=1)}>
                        <Card>
                            <Typography component={"span"} className={classes.twitterHeading}>
                                <ImageIcon className={classes.twitterIcon}/> {keyword("images_label")}
                                <Divider variant={"middle"}/>
                            </Typography>
                            <Box m={2}/>
                            <ImageGridList list={imageList} height={60} cols={5}
                                           handleClick={(event)=>{submitMediaToProcess(event.target.src)}}/>
                        </Card>
                    </Grid>

                    <Grid item xs = {6}
                          className={classes.newAssistantGrid}
                          hidden={(videoList.length===0 )||(imageList.length<=1 && videoList.length<=1)}>
                        <Card>
                            <Typography component={"span"} className={classes.twitterHeading}>
                                <DuoIcon className={classes.twitterIcon}/> {keyword("videos_label")}
                                <Divider variant={"middle"}/>
                            </Typography>
                            <Box m={2}/>
                            <VideoGridList list={videoList} handleClick={(vidLink)=>{submitMediaToProcess(vidLink)}}/>
                        </Card>
                    </Grid>

                    <Grid item xs={12}
                          hidden={inputUrl===null || (inputUrl!==null && imageList.length!==0 ) || videoList.length!==0}>
                        <Card><CardContent className={classes.assistantText}>
                            <Typography variant={"h6"} align={"left"}>
                                <FaceIcon size={"small"}/> {keyword("assistant_error")}
                            </Typography>
                            <Typography variant={"h6"} align={"left"}>
                                {keyword(helpMessage)}
                            </Typography>
                        </CardContent></Card>
                    </Grid>

                </Grid>

                <Grid item xs = {12} className={classes.newAssistantGrid}  hidden={urlMode===null || urlMode===true}>
                    <Box m={5}/>
                    <CloseResult hidden={urlMode===null || urlMode===false} onClick={() => dispatch(cleanAssistantState())}/>
                    <Typography component={"span"} variant={"h6"} >
                        <FaceIcon fontSize={"small"}/> {keyword("upload_type_question")}
                    </Typography>
                    <Box m={2}/>
                    <Button className={classes.button} variant="contained" color="primary" onClick={()=>{submitUpload(CONTENT_TYPE.VIDEO)}}>
                        {keyword("upload_video") || ""}
                    </Button>
                    <Button className={classes.button} variant="contained" color="primary" onClick={()=>{submitUpload(CONTENT_TYPE.IMAGE)}}>
                        {keyword("upload_image") || ""}
                    </Button>
                </Grid>

                <Grid item xs={12}>
                    {processUrlActions.length!==0 || imageVideoSelected === true ?  <AssistantResult/> : null}
                </Grid>
            </Grid>
        </Paper>
    )

};

export default Assistant;