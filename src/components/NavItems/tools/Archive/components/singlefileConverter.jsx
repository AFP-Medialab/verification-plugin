import React, { useState } from "react";

import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";

import FolderOpenIcon from "@mui/icons-material/FolderOpen";

import { i18nLoadNamespace } from "@Shared/Languages/i18nLoadNamespace";
import LoadingButton from "@mui/lab/LoadingButton";
import { downloadZip } from "client-zip";
import dayjs from "dayjs";
import { sha256 } from "hash-wasm";
import { CDXIndexer, WARCRecord, WARCSerializer } from "warcio";

import useAuthenticatedRequest from "../../../../Shared/Authentication/useAuthenticatedRequest";
import { prettifyLargeString } from "../utils";

/**
 *
 * The Singlefile HTML is read as a text,
 * passed first to warcio.js WARCRecord and WARCSerializer
 * to produce WARC formatted strings
 * CDXIndexer generates an index of the resources in the WARCRecord
 * Then the WARC strings and the index are gzipped
 * then combined into a WACZ, the total is hashed
 * and the digest value is sent to the authentication server for a signature
 * Once signed, the archive is downloaded.
 *
 * @param {*} telegramURL (passed in case a different URL needs to be set for the archive)
 * @returns
 */
const SinglefileConverter = (telegramURL) => {
  const keyword = i18nLoadNamespace("components/NavItems/tools/Archive");

  const [fileInput, setFileInput] = useState(/** @type {File?} */ null);
  const [error, setError] = useState("");
  const [processingSinglefile, setProcessingSinglefile] = useState(false);
  const authenticatedRequest = useAuthenticatedRequest();

  /**
   * Sends a request for domain signature to the authentication server
   * Input: @param hash digest value of the WACZ
   * @returns JSON Object with signature, timesignature, domain and timestamp certificates
   */
  const domainCertSign = async (hash) => {
    const resp = await authenticatedRequest({
      url: process.env.REACT_APP_WACZ_SIGNING + hash,
      method: "get",
    });
    if (resp.status === 200) {
      const respJson = resp.data;
      return respJson;
    } else {
      setError("Error signing WACZ, please try again");
      throw new Error("Error signing WACZ, please try again");
    }
  };

  //For anonymous signing
  // const sign = async (hash) => {
  //   //implementation derived from webrecorder's awp-sw library
  //   const keyPair = await crypto.subtle.generateKey(
  //     {
  //       name: "ECDSA",
  //       namedCurve: "P-384",
  //     },
  //     true,
  //     ["sign", "verify"],
  //   );

  //   const privateKey = await crypto.subtle.exportKey(
  //     "pkcs8",
  //     keyPair.privateKey,
  //   );
  //   const publicKey = await crypto.subtle.exportKey("spki", keyPair.publicKey);

  //   const keys = {
  //     private: encodeBase64(new Uint8Array(privateKey)),
  //     public: encodeBase64(new Uint8Array(publicKey)),
  //   };

  //   const data = new TextEncoder().encode(hash);
  //   const signatureBuff = await crypto.subtle.sign(
  //     {
  //       name: "ECDSA",
  //       hash: "SHA-256",
  //     },
  //     keyPair.privateKey,
  //     data,
  //   );
  //   const signature = encodeBase64(new Uint8Array(signatureBuff));
  //   return {
  //     signature,
  //     publicKey: keys.public,
  //   };
  // };

  /**
   * Encapsulates the different components of the WACZ into the archive
   * by filling pre-defined templates of each file (index, pages, data package...)
   * @param warcInput (the WARC generated from the singlefile by warcio.js)
   * @param cdxInput (the index file of the WARC generated by warcio.js)
   * @param pageInfo object containing info about the page being saved including date, url, title
   * @param recordDigest hash value of the page entry as saved in the WARC
   */
  const makeWacz = async (warcInput, cdxInput, pageInfo, recordDigest) => {
    const cdxInfo = JSON.parse(cdxInput);

    const index_input = `${cdxInfo.urlkey} ${cdxInfo.timestamp} {"url":"${cdxInfo.url}","digest":"sha256:${cdxInfo.digest}","mime":"text/html","offset":${cdxInfo.offset},"length":${cdxInfo.length},"recordDigest":"sha256:${recordDigest}","status":200,"filename":"data.warc.gz"}`;

    const index_arch = {
      name: "indexes/index.cdx",
      lastModified: new dayjs(),
      input: index_input,
    };

    const index_hash = await sha256(index_input);

    const pages_input = `{"format":"json-pages-1.0","id":"pages","title":"All Pages"}\n{"url":"${cdxInfo.url}", "id":"12345", "size":${cdxInfo.length}, "ts":"${dayjs(pageInfo.date).toISOString()}", "title":"${pageInfo.title}"}`;

    const pages_arch = {
      name: "pages/pages.jsonl",
      lastModified: dayjs(),
      input: pages_input,
    };

    const pages_hash = await sha256(pages_input);

    const archive_arch = {
      name: "archive/data.warc.gz",
      lastModified: dayjs(),
      input: warcInput,
    };

    const archive_buf = new Uint8Array(await warcInput.arrayBuffer());

    const archive_hash = await sha256(archive_buf);

    const datapackage_input = {
      profile: "data-package",
      resources: [
        {
          name: "pages.jsonl",
          path: "pages/pages.jsonl",
          hash: `sha256:${pages_hash}`,
          bytes: new TextEncoder().encode(pages_input).length,
        },
        {
          name: "data.warc.gz",
          path: "archive/data.warc.gz",
          hash: `sha256:${archive_hash}`,
          bytes: warcInput.size,
        },
        {
          name: "index.cdx",
          path: "indexes/index.cdx",
          hash: `sha256:${index_hash}`,
          bytes: new TextEncoder().encode(index_input).length,
        },
      ],
      wacz_version: "1.1.1",
      software:
        "InVID WeVerify plugin singlefile archiver with warcio.js 2.4.2",
      created: `${dayjs().toISOString()}`,
      title: "singlefile2wacz.wacz",
    };
    const datapackage_arch = {
      name: "datapackage.json",
      lastModified: dayjs(),
      input: JSON.stringify(datapackage_input, null, 2),
    };
    const datapackage_hash = await sha256(
      JSON.stringify(datapackage_input, null, 2),
    );

    // For anonymous signing
    // const signature = await sign(datapackage_hash);

    //Send request for signature and put info into the format required for the datapackage digest file

    try {
      const tstsign = await domainCertSign(datapackage_hash);
      const cleanCert = tstsign.domainCert.replace("\n", "");
      const cleantsCerts = tstsign.certs.join().replace("\n", "");
      const signedData = {
        hash: `sha256:${datapackage_hash}`,
        created: dayjs().toISOString(),
        software:
          "InVID WeVerify plugin singlefile archiver with warcio.js 2.4.2",
        signature: tstsign.signature,
        domain: "signature.verification-plugin.eu",
        domainCert: cleanCert,
        timeSignature: tstsign.encodedTST,
        timestampCert: cleantsCerts,
        version: "0.1.0",
      };

      const datapackagedigest_input = {
        path: "datapackage.json",
        hash: `sha256:${datapackage_hash}`,
        signedData: signedData,
      };

      const datapackagedigest_arch = {
        name: "datapackage-digest.json",
        lastModified: dayjs(),
        input: JSON.stringify(datapackagedigest_input, null, 2),
      };

      await downloadZip([
        datapackage_arch,
        datapackagedigest_arch,
        index_arch,
        pages_arch,
        archive_arch,
      ])
        .blob()
        .then((res) => {
          const blobUrl = URL.createObjectURL(res);
          const a = document.createElement("a");
          a.href = blobUrl;
          a.download = `singlefile2wacz.wacz`;
          a.click();
          setProcessingSinglefile(false);
        });
    } catch (error) {
      setError("Error signing WACZ, please try again");
      setProcessingSinglefile(false);
      console.error(error);
    }
  };

  /**
   * Passes the singlefile input first to WARC creator, then indexer then to the WACZ creator
   * @param {*} file2convert (The singlefile HTML)
   */

  const singlefile2wacz = async (file2convert) => {
    setError("");
    const reader = new FileReader();
    reader.onload = async () => {
      try {
        const lines = reader.result.split("\n");
        const getSFComment = (lines) => {
          for (let i = 0; i < lines.length; i++) {
            if (lines[i].includes("Page saved with SingleFile")) {
              return i;
            }
          }
          throw new Error("No singlefile comment found");
        };
        const commentline = getSFComment(lines);
        const pageDate = lines[commentline + 2].slice(12);
        const pageURL =
          telegramURL.telegramURL.length > 0
            ? telegramURL.telegramURL
            : lines[commentline + 1].slice(5);
        const pageDateISO = dayjs(pageDate).toISOString();
        const getTitle = () => {
          for (const l of reader.result.slice(0, 10000).split("\n")) {
            if (l.includes("<title>")) {
              const ret = l.match("<title>(.)*</title>")[0].slice(7, -8);
              const retbytes = new TextEncoder().encode(ret);
              return new TextDecoder("utf-8").decode(retbytes);
            }
          }
          return pageURL;
        };
        const pageInfo = {
          url: pageURL,
          date: pageDateISO,
          title: getTitle(),
        };
        await warcCreator(reader.result, pageURL, pageDateISO).then(
          async (res) => {
            let tmp = new Uint8Array(res[0].byteLength + res[1].byteLength);
            tmp.set(new Uint8Array(res[0]), 0);
            tmp.set(new Uint8Array(res[1]), res[0].byteLength);
            const recordDigest = await sha256(res[1]);

            const pako = require("pako");
            const res0 = pako.gzip(res[0]);
            const res1 = pako.gzip(res[1]);
            const res2 = pako.gzip(res[2]);
            const resbuf = new Uint8Array(
              res0.byteLength + res1.byteLength + res2.byteLength,
            );
            resbuf.set(res0, 0);
            resbuf.set(res2, res0.byteLength);
            resbuf.set(res1, res0.byteLength + res2.byteLength);
            const gzipArch = resbuf;

            const blob2 = new Blob([gzipArch], {
              type: "application/gzip",
            });

            const queuingStrategy = new CountQueuingStrategy({
              highWaterMark: 1,
            });
            const writableStream = new WritableStream(
              {
                write(chunk) {
                  return new Promise((resolve, reject) => {
                    makeWacz(blob2, chunk, pageInfo, recordDigest);
                    resolve();
                  });
                },
                close() {},
                abort(err) {
                  console.error("Sink error:", err);
                },
              },
              queuingStrategy,
            );

            const realIndexer = new CDXIndexer();

            await realIndexer.writeAll(
              [{ filename: "data.warc.gz", reader: blob2.stream() }],
              writableStream.getWriter(),
            );
          },
        );
      } catch (error) {
        console.error(error);
        setError("Error reading singlefile header");
        setProcessingSinglefile(false);
      }
    };
    reader.readAsText(file2convert, "utf-8");
  };

  /**
   * Converts the singlefile HTML into WARC format using warcio.js
   *
   * @param {*} fileContent Text result of reading the HTML Singlefile
   * @param {*} pageUrl  URL parsed from singlefile comment in HTML
   * @param {*} pageDate Date parsed from singlefile comment in HTML
   * @returns
   */
  const warcCreator = async (fileContent, pageUrl, pageDate) => {
    const warcVersion = "WARC/1.1";

    const info = {
      software:
        "InVID WeVerify plugin singlefile archiver with warcio.js 2.4.2",
      format: "WARC File Format 1.1",
      isPartOf: "singlefile2wacz.wacz",
    };
    const filename = "singlefile2wacz.wacz#/archive/data.warc.gz";

    const warcinfo = await WARCRecord.createWARCInfo(
      { filename, warcVersion },
      info,
    );

    const serializedWARCInfo = await WARCSerializer.serialize(warcinfo);

    // Create a sample response
    const url = pageUrl;
    const date = pageDate;
    const type = "response";
    const httpHeaders = {
      date: dayjs(),
      "content-type": 'text/html; charset="UTF-8"',
    };

    // For adding request record if page is saved as a response
    const trim = pageUrl.split(":")[1].slice(2).split("/");
    const host = pageUrl.split(":")[0] + "://" + trim[0];
    const addr = "/" + trim.slice(1).join("/");

    const samplereq = `GET ${addr} HTTP/1.1\nUser-Agent:  Mozilla/4.0 (compatible; MSIE5.01; Windows NT)\nHost: ${host}\nAccept-Language: en-us\nAccept-Encoding: gzip, deflate\nConnection: Keep-Alive\n`;

    async function* reqcontent() {
      yield new TextEncoder().encode(samplereq);
    }

    const reqRecord = await WARCRecord.create(
      { url, date, type: "request", warcVersion, statusline: "" },
      reqcontent(),
    );

    async function* content() {
      yield new TextEncoder().encode(fileContent);
    }

    const record = await WARCRecord.create(
      {
        url,
        date,
        type,
        warcVersion,
        httpHeaders,
        warcHeaders: { "content-type": 'text/html; charset="UTF-8"' },
      },
      content(),
    );

    const serializedRecord = await WARCSerializer.serialize(record);
    const serializedRequest = await WARCSerializer.serialize(reqRecord);

    return [serializedWARCInfo, serializedRecord, serializedRequest];
  };

  return (
    <div>
      <Box>
        <LoadingButton
          variant="outlined"
          loading={processingSinglefile}
          loadingPosition="start"
          startIcon={<FolderOpenIcon />}
          onClick={() => document.getElementById("file").click()}
        >
          {fileInput
            ? prettifyLargeString(fileInput.name, 25)
            : keyword("upload_singlefile")}
          <input
            id="file"
            name="file"
            type="file"
            accept={".html"}
            hidden={true}
            onChange={(e) => {
              e.preventDefault();
              setFileInput(e.target.files[0]);
              setProcessingSinglefile(true);
              singlefile2wacz(e.target.files[0]);
              e.target.value = null;
            }}
          />
        </LoadingButton>
      </Box>
      <Typography color={"error"}>{error}</Typography>
    </div>
  );
};

export default SinglefileConverter;
